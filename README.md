# gypse
Pseudo Compiler and Virtual Machine for experimental Cool-like toy language

It compiles a custom version of the Cool lang into a custom bytecode, to be executed by a custom virtual machine, 100% Rust.
It was inspired from this project: https://github.com/mykolav/coollang-2020-fs, with some differences: 
- choice to not generate real assembly and rather pseudo-bytecode with simple virtual machine (that has no voluntary concepts of OOP) to limit real-world issues with OS compatibility on generated code etc
-  explore some virtual machine concepts (virtual memory, syscalls, etc).

It is composed of:
- The gypse compiler: Compile program written in COOL language into custom bytecode
- The gypse virtual machine: Execute the compiled bytecode
- [common package shared between compiler and virtualmachine]
- [integration tests package]

#### Why?
Discover Rust, and learn about pseudo-bytecode compilation of an high-level simple language inspired from COOL. Not intended to be used or useful, just for fun.

## Cool language

The COOL language is derived from https://web.archive.org/web/20210823043833/http://www.cs.uwm.edu/classes/cs654/handout/cool-manual.pdf.
In this project only a subset is implemented:
- Inheritance (single) and polymorphism (virtual dispatch)
- Pattern matching
- If-else expressions that may return a value
- File imports

There are different types available:
- Primitive types (4-bytes words): Int, Bool
- Standard lib types that rely on syscalls: Any, String, Array
- Standard lib "pure" types: List, Tuple, Hashmap
- User-defined class types from the program

A very simple standard library is provided with the compiler, it contains common data structures: array, list, hashmap, plus some helpers (ex: quicksort).

## Gypse Compiler

The compiler takes as input source files in the COOL language and produce a binary executable for the Gypse virtual machine.

### Phase 1: Parsing
The COOL source code is parsed into an Abstract Syntax Tree, using the COOL grammar rules. Some syntax de-sugar can be performed to simplify the AST (ex: class constructor is generated).
The "imports" referenced by the main source file are also parsed recursively. The implicit imports on std.collection.Any and std.collection.String are explicitly added.

### Phase 2: Semantic check
**NOT IMPLEMENTED**: verify the AST semantic, and enrich it, ex: type checking, type inference, check method calls, etc

### Phase 3: Bytecode generation
Pseudo-assembly bytecode is generated by traversing the AST (single pass) on each method.
In this internal representation (IR) unlimited virtual registers are used.

#### Text section
The code is generated in the text section, it consists of a flat sequence of all methods of all imported classes, the main entry point method symbol is referenced in the header section.

#### Data section
- The Main object is allocated in the data section, this is the only object statically allocated (others are dynamically allocated on heap).
- Every hardcoded string is added to the data section.
- Every imported class VTABLE is allocated in the data section, it consists of:
    - A 4-byte pointer to the parent vtable (if different from "Any" root class), the address of this pointer will be used to determine at runtime the dynamic type of the object (using pattern matching)
    - For each virtual method: a 4-byte pointer to the virtual method address, relatively to the text section

### Phase 4: Register allocation
Expand the IR bytecode by replacing the virtual register (unlimited) by physical registers (limited to 16) using naive register allocation algorithm, that greedily allocate and spill registers when no more are available.

**NOT IMPLEMENTED**: Linear scan allocation (build the control flow graph and perform liveness analysis).

### Phase 5: Optimization
**NOT IMPLEMENTED**: Optimize the IR bytecode, ex:
 - simplify instructions (re-use existing registers, etc)
 - remove dead code
 - constant propagation
 - etc

### Phase 6: Executable generation
Generate a binary executable from the IR bytecode, with an header:
```rust
#[repr(C)]
struct ExecutableHeader {
    magic: [u8; 4],
    version: u8,
    flags: u8,
    entry: u32,
    data_header: SectionHeader,
    text_header: SectionHeader,
    debug_header: SectionHeader,
}

#[repr(C)]
struct SectionHeader {
    offset: u32,
    size: u32,
}
```
And for each section defined in the header binary data follows in this order:
- The data section: contains all static data, both initialized data (ex: string constants), and non-initialized data (the Main object that is statically allocated)
- The text section: contain the bytecode instructions, where each instruction is encoded this way:
  - [Optional, when debug is enabled] The address of the debug symbol in the debug section (4-bytes)
  - Instruction opcode (1-byte): 256 opcode max, currently ~30 opcode used.
  - Instruction flags (1-byte): [bits 0 to 1]: word size, [bits 2 to 3]: immediate flags, [bits 4 to 5]: address flags, [bit 6 to 7]: reserved
  - For each operand of the instruction (0, 1, or 2 operands):
    - If the operand is an immediate value: 1 (B), 2 (W), or 4 (L) bytes
    - If the operand is a data access (label):
      - 1-byte value to indicate the section type (mostly data section)
      - 4-bytes address relative to the section specified
    - If the operand is a register-based memory access:
      - 1-byte flags: the register code (3 bits), deref flag (1 bit), offset flag (1 bit), scale flag (1 bit) 
      - If offset flag is on: offset value (2-bytes)
      - If scale flag is on: scale value (compressed on 3-bits, can be either 1, 2, 4 or 8), scale register code (3 bits)
- The debug section: contains the bytecode source map for step-by-step debugger

## Gypse Virtual machine
It has the following properties:
- 32 bit architecture
- Little-endian
- Registers:
  - 16 general purpose registers (GP0 to GP15)
  - IP (instruction pointer)
  - SP (stack pointer)
  - SB (stack base pointer)
  - CR (call return value, short lived register)
  - FLAGS (the arithmetic flags for jump conditions),

### Virtual Memory
Each process has its own virtual memory on 32bit address space. The virtual pages are mapped on "physical" pages that are allocated inside the virtual machine.
When loading the binary executable, following sections are created in the process virtual memory:
- The text section: copied from the executable, starts at 0x00000000 address
- The data section: copied from the executable
- The debug section: copied from the executable
- The heap section: starts after above sections, uninitialized data, grows to higher addresses
- The stack section: starts at the max 0xFFFFFFFF address, grows to lower addresses.

#### Stack structure

The register SB points to the stack base, and the register SP points to the last element of the stack.
The stack frames are pushed to the bottom (lower addresses). Each stack frame consist of:

| Stack frame      | Register       | Address |
|------------------|----------------|---------|
| Previous SB      |                | High    |
| Argument N       | SB + 4*N       |         |
| ...              | ...            |         |
| Argument 1       | SB + 4         |         |
| "this" pointer   | SB             | Base    |
| "return" pointer |                |         |
| Local var 1      | SB - 8         |         |
| ...              | ...            |         |
| Local var N      | SB - 8*N or SP | Low     |

#### Heap structure

The heap is used for dynamic allocation (new operator), each allocated object has a base address on the head (the object reference) that always starts with a 4-byte identifier, that store the actual object class type (ex: for pattern matching). Then the object data is stored next to the class ID.
The data layout is defined at compile time.

**NOT IMPLEMENTED**: Garbage collector 

### Syscalls
Some system calls are implemented in the virtual machine, ex:
- Heap allocation (used by new operator)
- Exit process (available in Any class)
- Array internal allocation (only in Array class)
- String internal (only in String class)

### Debugger
When the executable is compiled with debug mode, the virtual machine can stop on breakpoints and allow to do step-by-step debugging, and allow to display heap, stack, and register information.

Available commands:
- next: go to next instruction,
- step N: step forward N instructions
- reg: display the register values
- stack: display the stack content
- heap: display the heap content
- data: display the data section content
- mem N: display the 4-byte word at N address
- resume: continue the execution until next breakpoint
- exit: terminate the process

## ideas for TODO

- improve register allocation and optimize generated bytecode
- improve graphics perf (per-pixel copy is so slow)
- cool string handling (remove string syscalls)
- negative numbers (!!!)
- operator precedence
- semantic checking
- garbage collector
- enrich standard lib and code samples
- incremental compilation
- ...